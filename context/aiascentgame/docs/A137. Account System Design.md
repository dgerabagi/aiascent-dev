# Artifact: A137. Account System Design (V.1.0)

(Content to be added by curator)# Artifact 137: Account System Design (V.1.0)
# Updated on: C1167 (Clarify where to find Google credentials.)
# Updated on: C1147 (Remove invalid `error` event handler from NextAuth options. Add types to event handler messages.)
# Date Created: Cycle 1146 (Revised from Supabase to NextAuth.js)
# Author: AI Model

## 1. Purpose

This document outlines the architecture and implementation plan for a user account system in AI Ascent. The primary goal is to provide a simple, secure, and integrated way for players to sign up, log in, and have their progress associated with a persistent identity. This system will serve as the foundation for future community features like a bulletin board system (BBS). This design uses a self-hosted backend approach.

## 2. Core Requirements & Technology Choice

*   **Simple Onboarding:** Must support Single Sign-On (SSO) with providers like Google and GitHub to minimize friction for the user.
*   **Integrated UI:** The login/signup flow must feel like a native part of the game, not a jarring redirect to a third-party branded page. This requires full control over the UI components.
*   **Self-Hosted Backend:** The authentication logic and user database must be self-hosted, connecting to an existing remote MySQL server.
*   **Secure & Standardized:** The implementation should use well-vetted, industry-standard libraries for handling authentication flows and database interactions.

### Technology Choice: NextAuth.js + Prisma + MySQL

This stack was chosen to meet all requirements within the existing project structure.

*   **Why this stack?**
    1.  **NextAuth.js (`Auth.js`):** The de-facto standard for authentication in Next.js applications. It provides pre-built providers for Google, GitHub, and many others, handling all the complexities of the OAuth 2.0 flow securely. It's highly customizable and unopinionated about the frontend.
    2.  **Prisma:** A modern, type-safe ORM that simplifies database interactions. It generates a fully-typed client based on a declarative schema, which prevents common errors and improves developer experience. Crucially, it has an official adapter for NextAuth.js (`@next-auth/prisma-adapter`).
    3.  **MySQL:** The chosen database, as per user requirements. Prisma has robust support for MySQL.
    4.  **Next.js API Routes:** We will leverage the built-in API routing of Next.js to host the NextAuth.js endpoint, keeping the entire application (frontend and auth backend) within a single codebase.

## 3. System Architecture

The account system will consist of several integrated parts within the `ai-ascent` project:

1.  **MySQL Database:** The remote, user-provided database that will store user and session information.
2.  **Prisma Schema (`src/prisma/schema.prisma`):** A declarative file that defines the data models required by the NextAuth.js Prisma adapter (`User`, `Account`, `Session`, `VerificationToken`). This schema is the source of truth for our database tables and the generated Prisma Client.
3.  **Prisma Client (`src/lib/prisma.ts`):** A singleton instance of the auto-generated Prisma client, used by the NextAuth.js adapter to communicate with the database.
4.  **NextAuth.js API Endpoint (`src/pages/api/auth/[...nextauth].ts`):** A catch-all API route that handles all authentication requests (e.g., `GET /api/auth/signin`, `POST /api/auth/callback/google`, `GET /api/auth/session`). It will be configured with the Google provider and the Prisma adapter.
5.  **NextAuth.js Session Provider (`src/components/UIRoot.tsx`):** The entire React application will be wrapped in a `<SessionProvider>`. This component efficiently fetches and shares the user's session state across all components, making it available via the `useSession` hook.
6.  **React UI Components:**
    *   **`<LoginModal />`:** A custom modal that displays "Sign in with..." buttons.
    *   **`<AuthButtonController />`:** A component in the `TopBar` that uses the `useSession` hook to reactively display either a "Login" button or the user's profile info and a "Logout" button.
7.  **Environment File (`.env`):** A file in the project root to store sensitive credentials like the `DATABASE_URL` and OAuth secrets. **Crucially, this file must be named `.env` (not `.env.local`) so that the Prisma CLI can automatically detect it.**

## 4. Data Schema (`src/prisma/schema.prisma`)

The following models are required by the `@next-auth/prisma-adapter` and will be defined in our schema file.

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
// Updated on: C1334 (Add ReportImageVote model.)
// Updated on: C1249 (Set default highestGameAIElo to 1000 for new players.)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// NextAuth.js Required Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  displayName   String?   @db.VarChar(50)
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  countryCode   String?   @db.Char(2)
  accounts      Account[]
  sessions      Session[]

  BbsThreads       BbsThread[]
  BbsPosts         BbsPost[]
  BbsVotes         BbsVote[]
  LeaderboardEntry LeaderboardEntry?
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// --- BBS & LEADERBOARD MODELS ---
model BbsThread {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(255)
  content   String   @db.Text
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  upvotes   Int      @default(0)
  downvotes Int      @default(0)

  posts BbsPost[]
  votes BbsVote[]
  tags  BbsTag[]

  @@index([authorId])
}

model BbsPost {
  id           String    @id @default(cuid())
  content      String    @db.Text
  authorId     String
  author       User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  threadId     String
  thread       BbsThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  parentPostId String?
  parentPost   BbsPost?  @relation("Replies", fields: [parentPostId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies      BbsPost[] @relation("Replies")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  upvotes      Int       @default(0)
  downvotes    Int       @default(0)

  votes BbsVote[]

  @@index([threadId])
  @@index([authorId])
  @@index([parentPostId])
}

model BbsVote {
  id       String     @id @default(cuid())
  userId   String
  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  threadId String?
  thread   BbsThread? @relation(fields: [threadId], references: [id], onDelete: Cascade)
  postId   String?
  post     BbsPost?   @relation(fields: [postId], references: [id], onDelete: Cascade)
  value    Int

  @@unique([userId, threadId])
  @@unique([userId, postId])
  @@index([threadId])
  @@index([postId])
}

model BbsTag {
  id      String      @id @default(cuid())
  name    String      @unique @db.VarChar(50)
  threads BbsThread[]

  @@index([name])
}

model LeaderboardEntry {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyName String?
  updatedAt   DateTime @updatedAt

  gameTimeElapsed        Float   @default(0)
  companyValuation       Float   @default(0)
  totalTokensGenerated   Float   @default(0)
  totalDataEnriched      Float   @default(0)
  totalFeatureLevels     Int     @default(0)
  totalProducts          Int     @default(0)
  highestGameAIElo       Int     @default(1000)
  highestProductPrestige Float   @default(0)
  companyScore           Float   @default(0)
  gameAiAgentName        String?
}

// --- NEW MODEL FOR REPORT DELIVERY SYSTEM (RDS) ---
model ReportImageVote {
  id        String   @id @default(cuid())
  imageId   String   @unique // e.g., "cc-p1-img-1" from the JSON data model
  voteCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

```

## 5. Authentication Flow

1.  **Initial Load:** The `<SessionProvider>` in `UIRoot.tsx` fetches the session state from the `/api/auth/session` endpoint.
2.  **Logged Out State:** The `useSession` hook in `<AuthButtonController />` returns `status: 'unauthenticated'`. The controller displays a "Login" button.
3.  **Initiate Login:** The player clicks the "Login" button, which calls `uiStore.openLoginModal()`.
4.  **Provider Selection:** The player clicks "Sign in with Google" inside the `<LoginModal />`. This calls the `signIn('google')` function from `next-auth/react`.
5.  **NextAuth.js Handles Flow:** NextAuth.js redirects the user to Google. After authentication, Google redirects back to our `/api/auth/callback/google` endpoint. NextAuth.js handles the code exchange, gets the user profile, and uses the Prisma adapter to find or create the user in the MySQL database. It then creates a session, stores the session token in a secure, `httpOnly` cookie, and redirects the user back to the game's main page.
6.  **Session Update:** The `<SessionProvider>` automatically detects the session change (via the cookie) and updates its context.
7.  **UI Update:** The `useSession` hook in `<AuthButtonController />` now returns `status: 'authenticated'` along with the user's data (`name`, `image`). The component re-renders to show the user's profile and a "Logout" button.
8.  **Logout:** The player clicks the "Logout" button. This calls the `signOut()` function, which instructs the NextAuth.js backend to invalidate the session and clear the session cookie. The `<SessionProvider>` context updates, and the UI reverts to the "Login" button.

## 6. Where to find Google Credentials

*   The `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` needed for your `.env` file are provided by Google after you create an "OAuth 2.0 Client ID" in the Google Cloud Console under **APIs & Services > Credentials**.
*   Refer to artifact `A138. Google OAuth Client ID Troubleshooting.md` for a detailed, step-by-step guide on creating these credentials and configuring the authorized redirect URIs.
